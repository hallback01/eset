#pragma once
#include "types.h"
#include <iostream>

namespace eset {

    class Set;

    /* Underlying reference data generated by the entity set */
    struct ReferenceData {
        size_t m_reference_count;
        void* m_raw_pointer;
        Entity m_entity;
        Set* m_set;
    };

    /*
        If you want to save a reference to a component, use this.
        Beacuse the data of an entity can shift archetype when 
        inserting or removing a component, the data will also
        be stored in a different place in the memory. Because
        of this, a raw pointer should not be used. This reference
        will change it's underlying raw pointer when the entity's
        component change.

        eset::Ref<Component> component = entity_set.get<Component>(entity);

        If you want to use a component once, without caring about
        the pointer's validity at a later point in time, the normal
        function "get_raw" that returns a raw pointer should be used
        instead because it is faster.

        Component* component = entity_set.get_raw<Component>(entity);
    */
    template<typename ComponentType>
    class Ref {
        public:

            /*
                Creates an empty reference, and should not
                be used.
            */
            Ref() : m_reference_data(nullptr) {}

            Ref(ReferenceData* reference_data) : m_reference_data(reference_data) {
                if(m_reference_data) {
                    m_reference_data->m_reference_count++;
                }
            }

            /*
                Copy constructor. Makes a copy
                and increases the reference count.
            */
            Ref(const Ref& other) : m_reference_data(other.m_reference_data) {
                if(m_reference_data) {
                    m_reference_data->m_reference_count++;
                }
            }

            /*
                Copy assignment operator. Makes a copy
                and increases the reference count.
            */
            Ref& operator=(const Ref& other) {
                if(this != &other) {
                    if(m_reference_data != other.m_reference_data) {
                        m_reference_data = other.m_reference_data;
                        if(m_reference_data) {
                            m_reference_data->m_reference_count++;
                        }
                    }
                }
                return *this;
            }

            /*
                Move construct one reference from one to the other, but makes
                the other an empty reference(invalid). No need
                to increase reference count
            */
            Ref(Ref&& other) : m_reference_data(other.m_reference_data) {
                other.m_reference_data = nullptr;
            }

            /*
                Moves one reference from one to the other, but makes
                the other an empty reference(invalid). No need
                to increase reference count
            */
            Ref& operator=(Ref&& other) {
                m_reference_data = other.m_reference_data;
                other.m_reference_data = nullptr;
                return *this;
            }

            /*
                Lowers the reference count by 1 in the underlying
                data. If the reference count becomes 0 after this,
                and the entity set is null, it will free the 
                underlying data's memory. If the entity set
                does exist, it will handle the deletion.
            */
            ~Ref() {
                if(m_reference_data) {
                    m_reference_data->m_reference_count--;
                    if(!m_reference_data->m_set) {
                        if(m_reference_data->m_reference_count == 0) {
                            delete m_reference_data;
                        }
                    } else {
                        if(m_reference_data->m_reference_count == 0) {
                            //let the set delete it
                            m_reference_data->m_set->delete_reference_pointer(m_reference_data);
                        }
                    }
                }
            }

            /*
                Returns the pointer to the entity set the component
                comes from. Can be null if the the set no longer exist.
            */
            Set* set() {
                return m_reference_data->m_set;
            }

            /*
                Returns the entity that the component is attached to.

                Returns eset::null if the underlying data is invalid.
                This could for example be the case if the entity no
                longer exists.
            */
            Entity entity() {
                return m_reference_data->m_entity;
            }

            /*
                Returns the amount of reference instances that are referencing this data.
            */
            size_t reference_count() {
                return m_reference_data->m_reference_count;
            }

            /*
                Returns true if the underlying raw pointer is valid
            */
            bool valid() {
                if(m_reference_data) {
                    return m_reference_data->m_raw_pointer != nullptr;
                } else {
                    return false;
                }
            }

            /*
                Operator to access the underlying pointer.
                This can throw a seg fault if the underlying data,
                or the raw pointer is null.
            */
            ComponentType* operator->() const {
                return (ComponentType*)m_reference_data->m_raw_pointer;
            }

            /*
                Function to access the get the data from
                the underlying raw pointer.
                This can throw a seg fault if the underlying data,
                or the raw pointer is null.
            */
            ComponentType* get() {
                return (ComponentType*)m_reference_data->m_raw_pointer;
            }

        private:
            ReferenceData* m_reference_data;
    };
}